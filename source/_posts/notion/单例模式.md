---
categories:
  - 设计模式
created_time: February 19, 2022 9:29 AM
date: 2018/07/10
excerpt: 由于使用Java的反射可以获取到类的私有构造器实例化对象，故为了保持单例的性质，在私有的构造方法中加一层判断来防止违背单例。
show_category: Yes
status: 待发布
tags:
  - 设计模式-创建型
updated_time: February 19, 2022 11:12 AM
title: 单例模式
---


## **单例模式之常规实现**

由于使用Java的反射可以获取到类的私有构造器实例化对象，故为了保持单例的性质，在私有的构造方法中加一层判断来防止违背单例。

```
 /**
  * 包名: com.elong.design.patterns
  * 创建人 : Elong
  * 时间: 2016/11/25 下午6:37
  * 描述 : 单例对象(第一种是公有静态final域, 第二种是公有静态工厂, 本例使用第二种)
  */
 class SingletonObject implements Serializable {
 
     private volatile static SingletonObject singletonObject = null;
     private String objName;
 
     private SingletonObject() {
         if (singletonObject != null)
             throw new IllegalArgumentException("单例模式不能创建新的实例了");
     }

     static SingletonObject getInstance() {
         synchronized (SingletonObject.class) {
             if (singletonObject == null)
                 singletonObject = new SingletonObject();
         }
         return singletonObject;
     }
 
     String getObjName() {
         return objName;
     }
 
     void setObjName(String objName) {
         this.objName = objName;
     }
 
     /**
      * 此方法保证在反序列化的时候保持单例
      */
     private Object readResolve(){
         return singletonObject;
     }
 
     public static void main(String[] args) {
         SingletonObject.getInstance();

         /*
          * 通过反射机制, 可以调用私有的无参构造函数(并非单例了)
          */
         try {
             Constructor<SingletonObject> constructor = SingletonObject.class.getDeclaredConstructor();
             constructor.setAccessible(true);
             SingletonObject invokeObj = constructor.newInstance();
             invokeObj.setObjName("invokeName");
             System.out.println(invokeObj.getObjName());
         } catch (Exception e) {
             e.printStackTrace();
         }
     }
 }
```

在构造方法中加入判断如果已经存在实例，抛出异常，防止产生多个实例。

```
 java.lang.reflect.InvocationTargetException
   at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
   at sun.reflect.NativeConstructorAccessorImpl.newInstance...
   ...
 Caused by: java.lang.IllegalArgumentException: 单例模式不能创建新的实例了
   at com.elong.design.patterns.SingletonObject.<init>(Singleton.java:61)
   ...
```

## **单例模式之枚举实现**

使用单元素的枚举类型来实现单例模式，相对于常规的单例模式 ，枚举实现的单例天生具有防止反射实例化对象和反序列化产生实例化对象，而且代码更加简洁，非常适合单例模式场景下使用。以下是枚举单例模式的实现。

```
 package com.elong.design.patterns;
 
 import java.lang.reflect.Constructor;
 import java.util.concurrent.TimeUnit;
 
 /**
  * 包名: com.elong.design.patterns
  * 创建人 : Elong
  * 时间: 2016/11/25 下午6:40
  * 描述 : 单元素的枚举类型实现单例
  * 枚举创建的单例具有天生抵抗反射创建对象
  */
 public enum EnumSingleton {
     INSTANCE; //单元素枚举实现单例
 
     private String objName;
 
     public String getObjName() {
         return objName;
     }
 
     public void setObjName(String objName) {
         this.objName = objName;
     }
 
     public static void main(String[] args) {
         EnumSingleton firstSingleton = EnumSingleton.INSTANCE;
         firstSingleton.setObjName("firstName");
         System.out.println(firstSingleton.getObjName());
 
         EnumSingleton secondSingleton = EnumSingleton.INSTANCE;
         secondSingleton.setObjName("secondName");
         System.out.println(firstSingleton.getObjName());
         System.out.println(secondSingleton.getObjName());
 
         try {
             TimeUnit.MILLISECONDS.sleep(1000);
         } catch (InterruptedException e) {
             e.printStackTrace();
         }
 
         try {
             Constructor<EnumSingleton> constructor = EnumSingleton.class.getDeclaredConstructor();
             constructor.setAccessible(true);
             EnumSingleton enumSingleton = constructor.newInstance();
             System.out.println(enumSingleton.getObjName());
         } catch (Exception e) {
             e.printStackTrace();
         }
 
     }
 }
```

## **单例模式常见用例**

1. Windows的Task Manager（任务管理器）就是很典型的单例模式.
2. 网站的计数器，一般也是采用单例模式实现，否则难以同步。
3. 应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。
4. Web应用的配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源。
5. 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，因为何用单例模式来维护，就可以大大降低这种损耗。
6. 多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。
7. 操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。