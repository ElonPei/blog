---
categories:
  - 设计模式
date: 2022/01/26
excerpt: 确保一个类只生成一个对象，并提供该实例的全局访问点。
show_category: Yes
status: 待发布
tags:
  - 设计模式-创建型
title: 单例模式
---


# 意图

确保一个类只生成一个对象，并提供该实例的全局访问点。

## 类图

![%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%20e5029fd8ac6240cf984df03ebbc823f8/Diagram.drawio.svg](/notion_images/b2860d46a7841743ebd80baf4b95b2dd.svg)

## 实现

饿汉式，线程安全，坏处是不节约资源。

```java
private static Singleton uniqueInstance = new Singleton();
```

懒汉式，线程安全的写法，好处是节约资源，坏处是在多线程的环境下，线程会阻塞时间过长，有性能问题，不建议试用该方法。

```java
public static synchronized Singleton getUniqueInstance() {
    if (uniqueInstance == null) {
        uniqueInstance = new Singleton();
    }
    return uniqueInstance;
}
```

双重校验锁，是线程安全的写法，这种写法高并发也没有问题，也是懒加载的。

```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

- volatile关键字可以防止指令重排序。
- `getUniqueInstance()` 中两个if判断必要的，第一个if避免了实例化之后的加锁操作，第二个if避免了多个线程同时实例化的现象。

静态内部类实现，懒加载，JVM能够保证实例只被实例化一次。

```java
public class Singleton {

    private Singleton() {
    }

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

## 现实中使用的场景

- [java.lang.System#getSecurityManager()](http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getSecurityManager--)
- [唯一ID工具-IdUtil](https://www.bookstack.cn/read/hutool/bfd2d43bcada297e.md)